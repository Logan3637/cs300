# cs300

# What was the problem you were solving in the projects for this course?
# We were initially going through loading and sorting incoming data. We did go through the types of sorting, pros and cons of each type, and how each one would sort with a csv file. We ran through pseudocode for each type of sort (vector, hash and BST) with loading the file, sorting it, searching for it, and printing it. In the final project we did it printing alphaneumerically. The goal was to see how each data structure can store, sort and retreive data. 

# How did you approach the problem? Consider why data structures are important to understand.
# Each problem was basically the same, figure out the base purpose or need for each structure, then go into building the structure step by step. For most of them the main focus was modular and could be easily copied from one project to the next with slight modifications, but the initial build was take it one step at a time. Vector was pretty straight forward and good for iterations but doesnt really scale well or use consistant insertions very well. Linked list were better for insert and delete. Hash tables gave constant-time access in the avergae case. BST gave ordered traversal for searching and inserting. It gave insight into why developers choose the types they do. 

# How did you overcome any roadblocks you encountered while going through the activities or project?
# Alot of the roadblocks were taken care of by debug outputs or step by step commenting. I would either put a FIX ME comment next to a few lines and changed the output to "FIX ME 1 complete" so if it hit that output it would tell me the fix me line is not the issue. Do that a few times and whichever number was not showing I knew it was either not reaching there or not doing its job while there. I did also do commenting entire blocks of code to see where the fault was when it wouldnt compile. Just take lines 50-100 out and if it compiled it was whatever was in there when the task list and error list were not sure where it was failing as it said over 300 errors on 120 line code. 

# How has your work on this project expanded your approach to designing software and developing programs?
# It opened my eyes to just how many different options there are for every problem or encounter you have. It really helped me think of not just the one way to fix it. If one way can do it what happens if we try it a different way to keep thinks simple or better time wise for the same project. Breaking habit choices. It helped write more modular code so debugging and testing easier.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
# I learned clear coding and comments, direct and point blank function/variable names, and abstraction helps keep things organized. The pseudocode before writing the code made it more direct on my intent which could use some tidying up. It helped me learn that data structures are just as important as making it run on scale. 
